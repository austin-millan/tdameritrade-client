/*
 * TD Ameritrade API
 *
 * TD Ameritrade API
 *
 * API version: 3.0.1
 * Contact: austin.millan@protonmail.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// InstrumentType - struct for InstrumentType
type InstrumentType struct {
	CashEquivalent *CashEquivalent
	Equity *Equity
	FixedIncome *FixedIncome
	MutualFund *MutualFund
	Option *Option
}

// CashEquivalentAsInstrumentType is a convenience function that returns CashEquivalent wrapped in InstrumentType
func CashEquivalentAsInstrumentType(v *CashEquivalent) InstrumentType {
	return InstrumentType{ CashEquivalent: v}
}

// EquityAsInstrumentType is a convenience function that returns Equity wrapped in InstrumentType
func EquityAsInstrumentType(v *Equity) InstrumentType {
	return InstrumentType{ Equity: v}
}

// FixedIncomeAsInstrumentType is a convenience function that returns FixedIncome wrapped in InstrumentType
func FixedIncomeAsInstrumentType(v *FixedIncome) InstrumentType {
	return InstrumentType{ FixedIncome: v}
}

// MutualFundAsInstrumentType is a convenience function that returns MutualFund wrapped in InstrumentType
func MutualFundAsInstrumentType(v *MutualFund) InstrumentType {
	return InstrumentType{ MutualFund: v}
}

// OptionAsInstrumentType is a convenience function that returns Option wrapped in InstrumentType
func OptionAsInstrumentType(v *Option) InstrumentType {
	return InstrumentType{ Option: v}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *InstrumentType) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into CashEquivalent
	err = json.Unmarshal(data, &dst.CashEquivalent)
	if err == nil {
		jsonCashEquivalent, _ := json.Marshal(dst.CashEquivalent)
		if string(jsonCashEquivalent) == "{}" { // empty struct
			dst.CashEquivalent = nil
		} else {
			match++
		}
	} else {
		dst.CashEquivalent = nil
	}

	// try to unmarshal data into Equity
	err = json.Unmarshal(data, &dst.Equity)
	if err == nil {
		jsonEquity, _ := json.Marshal(dst.Equity)
		if string(jsonEquity) == "{}" { // empty struct
			dst.Equity = nil
		} else {
			match++
		}
	} else {
		dst.Equity = nil
	}

	// try to unmarshal data into FixedIncome
	err = json.Unmarshal(data, &dst.FixedIncome)
	if err == nil {
		jsonFixedIncome, _ := json.Marshal(dst.FixedIncome)
		if string(jsonFixedIncome) == "{}" { // empty struct
			dst.FixedIncome = nil
		} else {
			match++
		}
	} else {
		dst.FixedIncome = nil
	}

	// try to unmarshal data into MutualFund
	err = json.Unmarshal(data, &dst.MutualFund)
	if err == nil {
		jsonMutualFund, _ := json.Marshal(dst.MutualFund)
		if string(jsonMutualFund) == "{}" { // empty struct
			dst.MutualFund = nil
		} else {
			match++
		}
	} else {
		dst.MutualFund = nil
	}

	// try to unmarshal data into Option
	err = json.Unmarshal(data, &dst.Option)
	if err == nil {
		jsonOption, _ := json.Marshal(dst.Option)
		if string(jsonOption) == "{}" { // empty struct
			dst.Option = nil
		} else {
			match++
		}
	} else {
		dst.Option = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.CashEquivalent = nil
		dst.Equity = nil
		dst.FixedIncome = nil
		dst.MutualFund = nil
		dst.Option = nil

		return fmt.Errorf("Data matches more than one schema in oneOf(InstrumentType)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("Data failed to match schemas in oneOf(InstrumentType)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src InstrumentType) MarshalJSON() ([]byte, error) {
	if src.CashEquivalent != nil {
		return json.Marshal(&src.CashEquivalent)
	}

	if src.Equity != nil {
		return json.Marshal(&src.Equity)
	}

	if src.FixedIncome != nil {
		return json.Marshal(&src.FixedIncome)
	}

	if src.MutualFund != nil {
		return json.Marshal(&src.MutualFund)
	}

	if src.Option != nil {
		return json.Marshal(&src.Option)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *InstrumentType) GetActualInstance() (interface{}) {
	if obj.CashEquivalent != nil {
		return obj.CashEquivalent
	}

	if obj.Equity != nil {
		return obj.Equity
	}

	if obj.FixedIncome != nil {
		return obj.FixedIncome
	}

	if obj.MutualFund != nil {
		return obj.MutualFund
	}

	if obj.Option != nil {
		return obj.Option
	}

	// all schemas are nil
	return nil
}

type NullableInstrumentType struct {
	value *InstrumentType
	isSet bool
}

func (v NullableInstrumentType) Get() *InstrumentType {
	return v.value
}

func (v *NullableInstrumentType) Set(val *InstrumentType) {
	v.value = val
	v.isSet = true
}

func (v NullableInstrumentType) IsSet() bool {
	return v.isSet
}

func (v *NullableInstrumentType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableInstrumentType(val *InstrumentType) *NullableInstrumentType {
	return &NullableInstrumentType{value: val, isSet: true}
}

func (v NullableInstrumentType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableInstrumentType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


